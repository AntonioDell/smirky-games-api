import crypto from "https://deno.land/std@0.84.0/node/crypto.ts";
import { Buffer } from "http://deno.land/x/node_buffer/index.ts";

/**
 * Using crypto.pbkdf2 results in very bad performance, regardless of settings.
 * Because of this, we use the default pbkdf2 node package through jspm.
 */
import { pbkdf2 as pbkdf2Import } from "https://jspm.dev/pbkdf2";
/** This line is used to fix a typescript error. */
const pbkdf2: any = pbkdf2Import;

const defaults = {
  /**
     * size of the generated hash
     */
  hashBytes: 32,

  /**
     * A larger salt means hashed passwords are more resistant to rainbow table, but
     * you get diminishing returns pretty fast.
     */
  saltBytes: 16,

  /**
     * A selected HMAC digest algorithm specified by digest is applied to derive
     * a key of the requested byte length (keylen) from the password, salt and
     * iterations.
     * - sha512, sha256
     * - whirlpool
     * and more.
     */
  digest: "sha512",

  /**
     * More iterations means an attacker has to take longer to brute force an
     * individual password, so larger is better. however, larger also means longer
     * to hash the password. tune so that hashing the password takes about a
     * second.
     */
  iterations: 50999,
  /** 
     * Originally 'binary' was used as encoding. But that resulted in problems when 
     * using 'Buffer.from'. Hex is a better fit in deno it seems.
     */
  encoding: "hex",
};

/**     
 * A promise for the hashed password by the options supplied to the hashing function.
 *
 * @promise PaswordHashingPromise
 * @fulfill {string} The hashed password.
 * @reject {Error} Internal error of the hashing function. Check the returned error for details.
 *
 * Hash a password using Node's asynchronous pbkdf2 (key derivation) function.
 *
 * Returns a self-contained hexadecimal encoded buffer that contains all the data needed to verify a password.
 *
 * @param {!string} password
 * @return {PaswordHashingPromise} A promise for the hashed password by the options supplied to the hashing function.
 */
export function hashPassword(password: any) {
  return new Promise((resolve, reject) => {
    crypto.randomBytes(defaults.saltBytes, (err: any, salt: any) => {
      if (err) {
        reject(err);
      }
      resolve(salt);
    });
  }).then((salt: any) => {
    return new Promise((resolve, reject) => {
      let start = Date.now();
      pbkdf2(
        password,
        salt,
        defaults.iterations,
        defaults.hashBytes,
        defaults.digest,
        (err: any, hash: any) => {
          if (err) {
            reject(err);
          }

          let combined = Buffer.alloc(hash.length + salt.length + 8);

          /**
				 *  The size of the salt is also included so that we can figure out
				 *  how long the salt is in the hash during verification
				 */
          combined.writeUInt32BE(salt.length, 0);

          /**
				 * Similarly, iteration count is included
				 */
          combined.writeUInt32BE(defaults.iterations, 4);

          salt.copy(combined, 8);
          hash.copy(combined, salt.length + 8);
          console.log(`pbkdf2 used ${Date.now() - start}ms to execute.`);
          resolve(combined.toString(defaults.encoding));
        },
      );
    });
  });
}

/**
 * A promise for comparing an incoming plain password with a hash.
 *
 * @promise IncomingPasswordHashComparePromise
 * @fulfill {boolean} Whether the incoming plain password and the hash is a match.
 * @reject {Error} Internal error of the hashing function. Check the returned error for details.
 *
 * Verify a password using Node's asynchronous pbkdf2 (key derivation) function.
 * It accepts a hash and salt generated by hashPassword, and returns a promise that resolves 
 * whether the hash matches the password (as a boolean). 
 *
 * @param {!string} password
 * @param {!string} combined
 * @return {IncomingPasswordHashComparePromise} A promise for comparing an incoming plain password with a hash
 */
export function verifyPassword(password: any, combined: any) {
  return new Promise((resolve, reject) => {
    let buffer = Buffer.from(combined, defaults.encoding);

    /**
		 *	Extract the salt and hash from the combined buffer
		 */
    let saltBytes = buffer.readUInt32BE(0);
    let salt = buffer.slice(8, saltBytes + 8);

    let hashBytes = buffer.length - saltBytes - 8;
    let iterations = buffer.readUInt32BE(4);

    let hash = buffer.toString(defaults.encoding, saltBytes + 8);

    /**
    *   verify the salt and hash against the password
    */
    let start = Date.now();

    pbkdf2(
      password,
      salt,
      iterations,
      hashBytes,
      defaults.digest,
      function (err: any, verify: any) {
        if (err) {
          reject(err);
        }
        console.log(`pbkdf2 used ${Date.now() - start}ms to execute.`);
        resolve(verify.toString(defaults.encoding) === hash);
      },
    );
  });
}

/**
 * Example: A user with a hashed value. Below is the plaintext password string. 
 * 'pѬѬasѪ"§§)("!编/)$=?!°&%)?§"$(§sw汉字编码§"$(§sw汉字方法orФdpѬѬasѪ"§§)("!/)$=?!°&%)?编码方法orФd'
 */
async function testEncryption() {
  const testUser = {
    "hash":
      "000000100000c737d94c5a62d214e2998ee2a31b4cf628d3bb90478cbe76174d1cf054966cb45f4a0a9894a72c8b5906ac95125978deb6f9",
  };

  let start = Date.now();
  console.log("Start hashPassword...");
  try {
    const hash = await hashPassword(
      'pѬѬasѪ"§§)("!编/)$=?!°&%)?§"$(§sw汉字编码§"$(§sw汉字方法orФdpѬѬasѪ"§§)("!/)$=?!°&%)?编码方法orФd',
    );
    console.log("hashPassword success. Hash is", hash);
  } catch (err) {
    console.log("hashPassword failed. Error:", err);
  }
  let time = Date.now() - start;
  console.log(`hashPassword used ${time}ms`);

  start = Date.now();
  console.log("Start verifyPassword...");
  try {
    const match = await verifyPassword(
      'pѬѬasѪ"§§)("!编/)$=?!°&%)?§"$(§sw汉字编码§"$(§sw汉字方法orФdpѬѬasѪ"§§)("!/)$=?!°&%)?编码方法orФd',
      testUser.hash,
    );
    console.log(`verifyPassword has found ${match ? "one" : "no"} match.`);
  } catch (err) {
    console.log("verifyPassword failed. Error:", err);
  }
  time = Date.now() - start;
  console.log(`verifyPassword used ${time}ms`);
}